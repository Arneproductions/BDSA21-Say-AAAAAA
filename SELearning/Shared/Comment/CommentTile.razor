@using SELearning.Core.Comment;
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Net;

@inject HttpClient Http
@inject IJSRuntime JsRuntime
@inject ToastService toasts;

<div class="row col-lg-12 comment">
    <div class="col-lg-2 row comment-rating">
        <!--Rating section-->
        <div class="col-lg-4">
            <p class="row col-lg-12">@Comment.Rating</p>
            <p class="row col-lg-12">Rating</p>
        </div>
        <div class="col-lg-8">
            <div class="btn-group" role="group" aria-label="...">
                <button type="button" class="btn btn-default btn-lg" aria-label="Left Align" @onclick="UpVote">
                    <span class="oi oi-thumb-up"></span>
                </button>
                <button type="button" class="btn btn-default btn-lg" @onclick="DownVote">
                    <span class="oi oi-thumb-down"></span>
                </button>
            </div>
        </div>

    </div>
    <div class="col-lg-9">
        <!-- Content section -->
        <div class="row">
            <!-- Content header section -->
            <p class="col-lg-11">
                <b>@Comment.Author.Name</b>
            </p>
            <div class="col-lg-1">
                <button type="button" class="btn btn-default btn-lg text-danger" aria-label="Left Align" @onclick="Delete">
                        <span class="oi oi-trash"></span>
                </button>
            </div>
        </div>
        <div class="row">
            <p>@Comment.Text</p>
        </div>
    </div>
</div>

@code {

    [Parameter]
    public CommentDetailsDTO Comment { get; set; }

    [Parameter]
    public EventCallback<CommentDetailsDTO> OnCommentDeleted { get; set; }

    private async Task Delete()
    {
        try
        {
            var responseMessage = await Http.DeleteAsync($"Comment/{Comment.Id}");

            if (responseMessage.StatusCode == HttpStatusCode.Forbidden)
            {
                toasts.AddToast(ToastNotification.CreateUnauthorized("delete comments"));
                return;
            }
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        catch (Exception exception)
        {
            await this.Alert(exception);
        }
    }

    private async Task UpVote()
    {
        try
        {
            var responseMessage = await Http.PutAsync($"Comment/{Comment.Id}/Upvote", null);

            if (responseMessage.StatusCode == HttpStatusCode.Forbidden)
            {
                toasts.AddToast(ToastNotification.CreateUnauthorized("rate"));
                return;
            }
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        catch (Exception exception)
        {
            await this.Alert(exception);
        }
    }

    private async Task DownVote() 
    {
        try
        {
            var responseMessage = await Http.PutAsync($"Comment/{Comment.Id}/Downvote", null);

            if (responseMessage.StatusCode == HttpStatusCode.Forbidden)
            {
                toasts.AddToast(ToastNotification.CreateUnauthorized("rate"));
                return;
            }
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        catch (Exception exception)
        {
            await this.Alert(exception);
        }
    }

    // TODO: Place this somewhere else
    // TODO: If there is time, replace with a toast notification?
    private async Task Alert(Exception exception) {
        await JsRuntime.InvokeVoidAsync("alert", exception.ToString());
        System.Console.WriteLine(exception);
    }
}